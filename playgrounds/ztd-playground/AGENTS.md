# ztd-playground AGENTS

This playground exists to validate the ZTD development loop end-to-end against a real Postgres connection without creating physical tables. Follow these rules when working inside this package.

## Generated files (important)

- `tests/generated/` is auto-generated and must never be committed.
- After cloning the repository (or in a clean environment), run:
  - `pnpm --filter rawsql-ts run build`
  - `pnpm --filter @rawsql-ts/testkit-core run build`
  - `pnpm --filter @rawsql-ts/ztd-cli run build`
  - `pnpm --filter ztd-playground exec ztd ztd-config`
- If TypeScript reports missing modules or type errors because `tests/generated/` is missing, run:
  - `pnpm --filter rawsql-ts run build`
  - `pnpm --filter @rawsql-ts/testkit-core run build`
  - `pnpm --filter @rawsql-ts/ztd-cli run build`
  - `pnpm --filter ztd-playground exec ztd ztd-config`

## 1. Use the Postgres testkit helper

- Always wire Postgres execution through `tests/support/testkit-client.ts`, which opens a `pg.Client`, passes it into `@rawsql-ts/pg-testkit`, and shares the connection across tests.
- Set `ZTD_EXECUTION_MODE=traditional` or pass `{ mode: 'traditional', traditional: { isolation: 'schema', cleanup: 'drop_schema' } }` to the helper when you must test against a real schema (locking, isolation, constraints, etc.). Traditional mode creates/drops an isolated schema, executes `ztd/ddl`, seeds the fixtures, runs any optional `setupSql`, and honors the configured cleanup strategy so the database stays tidy.
- `DATABASE_URL` may be provided explicitly, but when it is missing the test runner starts exactly one disposable Postgres testcontainer via `tests/support/global-setup.ts`.
- Never issue DDL statements against Postgres from the playground. All CRUD operations must flow through pg-testkit so they resolve to fixture-backed `SELECT` queries.

## Parallel test policy (important)

- ZTD tests **should be safe to run in parallel** against a single Postgres instance because no physical tables are created or mutated.
- Do **not** start multiple Postgres instances per test file/worker, and do **not** isolate tests by creating per-test databases or schemas. This is unnecessary for ZTD and adds failure modes.
- Prefer one shared Postgres instance + multiple connections (what Vitest workers do), limited only by your DB resources.

## 2. Treat the ZTD layout as the single source of truth

- Keep every table definition inside `ztd/ddl/<schema>.sql`, enums under `ztd/enums/*.md`, and executable specs inside `ztd/domain-specs/*.md`.
- Keep exactly one executable SQL block per enum/spec file (one file = one definition).
- Never edit files under `tests/generated/`. Regenerate them with `pnpm --filter ztd-playground exec ztd ztd-config` so the CLI and tests stay aligned.
- `tests/generated/ztd-row-map.generated.ts` (TestRowMap + table schemas) is generated by `pnpm --filter ztd-playground exec ztd ztd-config` and is the canonical source for typed fixtures.

## 3. `tests/generated/ztd-row-map.generated.ts` defines typed fixtures

- Import `ZtdConfig`, `ZtdRowShapes`, `ZtdTableName`, and `tableFixture()` from `tests/generated/ztd-row-map.generated.ts`.
- Trust the generated helpers for row shapes instead of duplicating row interfaces inside tests.

## 4. Keep tests deterministic

- Provide explicit fixtures for each test:

```ts
tableFixture('schema.table', [{ ... }])
```

- Do not reuse shared mutable data between tests.
- Do not insert, update, or delete data directly; rely on the rewrite helper instead.

## 5. Keep the playground minimal

- Only include:
  - DDL files
  - minimal SQL examples in `src/`
  - ZTD-focused tests under `tests/`
- Avoid adding application logic, persistence layers, or business services.

## 6. Formatting and linting

- Use `pnpm format` to normalize TypeScript, SQL, Markdown, and config files; do not hand-edit whitespace or indentation.
- Run `pnpm lint` regularly and `pnpm lint:fix` when ESLint reports autofixable issues; these scripts are the single source of truth for formatting/linting.
- The `simple-git-hooks` pre-commit hook triggers `lint-staged`, so staged files already run through `pnpm format` before commits land.
