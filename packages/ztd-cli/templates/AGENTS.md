# Appendix: Development Workflow Using Zero Table Dependency (ZTD)

This application uses **Zero Table Dependency (ZTD)** as an internal development workflow for writing, testing, and maintaining SQL logic.
ZTD is not part of the application's runtime behavior; rather, it provides a framework for:

- Maintaining consistent SQL across the project
- Keeping schema metadata and generated artifacts synchronized
- Ensuring deterministic SQL unit tests
- Enabling structured collaboration between humans and AI

This section documents how ZTD is used inside this repository as a development methodology.

---

## Defaults (important)

- This project adopts **ZTD as the default development and testing methodology**.
- ZTD is assumed unless explicitly stated otherwise.
- Detailed rules about test execution modes are defined in `templates/tests/AGENTS.md`.

---

## Generated files (important)

- `tests/generated/` is auto-generated and must never be committed.
- After cloning the repository (or in a clean environment), run `npx ztd ztd-config`.
- If TypeScript reports missing modules or type errors because `tests/generated/` is missing, run `npx ztd ztd-config`.

---

## TypeScript validation (required)

After any code change, TypeScript type checking **must** be performed and must pass.

- Run the project-appropriate typecheck command (e.g. `pnpm typecheck`).
- If generated files are involved, run generators first, then re-run typecheck.
- If typecheck fails, fix errors by root cause, not only the first reported error.
- A change is not considered complete unless typecheck is green.
CI pipelines SHOULD run `npx ztd ztd-config` before typecheck and tests (recommended).

Rationale:  
In ZTD-based development, many schema or SQL inconsistencies surface first as TypeScript errors via generated row maps and DTOs.
Type checking is a primary correctness signal, not an optional step.

---

## ZTD Implementation Guide (src/)

The `src/` directory should contain pure TypeScript logic that operates on the row interfaces generated by `tests/generated/ztd-row-map.generated.ts`. Tests should import the row map, repositories should import DTOs, and fixtures must stay under `tests/`. Keep production code decoupled from the generated row map to preserve the distinction between implementation and test scaffolding.

### Runtime dependency boundaries (important)

- Code under `src/` MUST NOT import anything from `tests/` or `tests/generated/`.
- Generated row-maps are test-only artifacts and MUST NEVER influence runtime behavior.
- Mapper and writer runtime utilities MUST NOT depend on ZTD internals or generated helpers.
- All schema compatibility checks (column existence, enum coverage, forbidden columns, etc.) MUST be enforced in tests, never in production code.

### Repository Classes: What to Care About

#### Scope and Responsibility
- Repository classes are responsible for executing SQL and returning query results.
- Avoid embedding business logic, thresholds, or data reshaping inside repositories.
- Treat repositories as thin adapters over SQL.

#### Mandatory testing rule (important)

Whenever a repository class is created or modified, corresponding tests **must** be created or updated.

Rules:
- Every public repository method must be covered by tests.
- Tests must call repository methods, not raw SQL files or SQL strings.
- ZTD fixtures are the only allowed source of database state in tests.
- A repository change without tests is considered incomplete.

Rationale:  
ZTD derives much of its value from deterministic, repository-level tests.
Without tests, schema drift and SQL inconsistencies cannot be detected.

#### SQL Management
- Prefer keeping SQL in separate `.sql` files.
  - If no explicit instruction is given, separate SQL into files by default.
- Repository classes should reference SQL files by name, not inline long SQL strings.

#### Specifications and Documentation
- If a markdown file with the same base name as the repository or SQL exists, read it before implementation.
  - Such files may contain repository-local specifications (e.g. decision tables, thresholds, request/response notes).
  - Naming should be aligned (e.g. `FooRepository.ts`, `foo.sql`, `foo.md`).

#### Request and Response Contracts
- Be explicit about request parameters (types, nullability, constraints).
- Be explicit about response shape (columns, ordering, cardinality).
- Prefer documenting contracts in the repository-local markdown file rather than code comments when they are non-trivial.

### SqlClient lifecycle policy (important)

- When using `src/db/sql-client.ts`, prefer a shared `SqlClient` per worker process (singleton).
- Avoid creating a new database connection for every query or test case.
- Do not share a live connection across parallel workers; each worker should own its own shared client or pool.
- If you need strict isolation, create a dedicated client for that scope and close it explicitly.

### Repository SQL and DTO policy (important)

- Repository SQL must return application-facing DTO shapes.
- SQL SELECT statements should alias columns to camelCase and match the repository return types.
- Do not introduce intermediate `*Row` types when SQL already returns DTO-compatible shapes.
- Define separate Row types only when SQL intentionally returns database-shaped (snake_case) rows, and always convert them explicitly.

### Mapper + writer guardrails (template-specific)

- In this project, `src/repositories/user-accounts.ts` is the authoritative mapper for the columns defined by the DDL and any optional references; it MUST enumerate those columns explicitly so downstream logic never infers metadata at runtime.
- Writer helpers in the same module MUST emit SQL for `public.user_account` only and MUST remain limited to the explicit insert/update/delete helpers shown there; DO NOT introduce ad-hoc schema discovery.
- `tests/writer-constraints.test.ts` MUST consume `userAccountWriterColumnSets` together with `tests/generated/ztd-row-map.generated.ts` so CUD callers only reference columns that exist on `public.user_account`.
- When the schema of `public.user_account` changes, update `src/repositories/user-accounts.ts` column metadata, keep `tests/writer-constraints.test.ts` expectations aligned, and re-run `npx ztd ztd-config` so the generated row map stays synchronized with the tests.

#### Writer safety contract (important)

- Allowed:
  - Insert, update, and delete helpers tied to a single table with explicitly enumerated column sets.
  - Explicit `RETURNING` clauses that list permitted columns.
  - Patch-style updates that only touch writable columns listed in `userAccountWriterColumnSets`.
- Forbidden:
  - Generic writers that accept arbitrary table or column names.
  - Runtime schema or enum discovery (e.g., querying `information_schema`) to drive writer column lists.
  - Writers that embed joins or subqueries beyond simple `RETURNING` clauses.
If these constraints are insufficient, write the SQL manually.

#### Mapper strictness policy

- Mapping is strict by default: SQL must return exactly the DTO-shaped results that `src/repositories/user-accounts.ts` exposes; missing or mismatched columns are bugs that tests MUST surface.
- Non-strict behaviors (coercions, key transforms, etc.) MUST be enabled explicitly via named presets or configuration; relying on implicit or silent defaults is prohibited.

### Sequence / identity column policy (important)

- Sequence / identity columns (auto-generated IDs) are infrastructure concerns.
- Do not explicitly assign values to sequence / identity columns in `INSERT` statements unless explicitly instructed.
- Repository method inputs should omit sequence / identity columns by default.
- Only treat an ID as input data when it represents a business rule (e.g. natural keys, externally assigned IDs).

### No test-driven fallbacks in production code (important)

- Do not add fallbacks in `src/` that exist only to accommodate ZTD/testkit/rewriter limitations.
- If a query fails to be rewritten into ZTD form, do not change runtime behavior to compensate.
- Report tooling issues with minimal reproduction and expected behavior.

Rationale:  
Production code must not diverge from intended SQL semantics due to tooling constraints.

---

## ZTD Test Guide (tests/)

Testing under ZTD follows dedicated, directory-scoped rules.

- Test design, execution mode selection, and constraints are defined in:
  - `templates/tests/AGENTS.md`
- Tests validate repository behavior and returned DTOs.
- Raw SQL files or SQL strings must not be tested directly.

---

# ZTD Directory Layout

```
/ztd
  /ddl
    *.sql               <- physical schema definitions

  /domain-specs          <- optional behavioral notes (informational only)
  /enums                 <- optional canonical value sets (informational only)

  README.md             <- documentation for the layout
  AGENTS.md             <- combined guidance for DDL and optional references

/src                    <- application & repository logic
/tests                  <- ZTD tests, fixtures, row-maps
```

The file `tests/generated/ztd-layout.generated.ts` ensures ZTD CLI always points to the correct directories.

---

# Protected directories and edit ownership (important)

- DDL editing is human-led: `ztd/ddl/`
- Optional reference directories (`ztd/domain-specs/`, `ztd/enums/`) are informational; do not treat them as human-led constraints unless explicitly instructed.
- These directories are optional and MUST NOT be treated as inputs or constraints unless a human explicitly requests them.
- Do not read domain-specs or enums unless directly instructed; the only authoritative source is `ztd/ddl`.
- Application code is shared ownership: `src/`
- Tests are shared ownership: `tests/`
  - Detailed test constraints live in `templates/tests/AGENTS.md`.

Additionally:
- Never modify `ztd/AGENTS.md` or `ztd/README.md` without explicit instruction.
- When changes are required in human-led directories, prefer proposing a patch and explaining the impact before applying it.

---

# Principles of ZTD in This Repository

### 1. Humans own the definitions
- Physical schema (DDL)
- Repository interfaces

### 2. AI assists with implementation
- Generating repository SQL
- Updating fixtures
- Producing intermediate TypeScript structures
- Ensuring SQL adheres to DDL

### 3. ZTD enforces consistency
ZTD tests verify that:
- SQL logic matches DDL shapes

If anything diverges, ZTD failures surface immediately and deterministically.

---

# Development Workflows

Different types of changes start from different entry points. Use the workflow appropriate for your situation.

---

# Workflow A - Starting From DDL Changes
Modifying tables, columns, constraints, indexes.

1. Edit DDL files in `ztd/ddl/`.
2. Run `npx ztd ztd-config`.
3. Update repository SQL to match the new schema.
4. Update fixtures if result shapes changed.
5. Run tests.

Flow: DDL to Repository SQL to Fixtures and Tests to Application

---

# Workflow B - Starting From Repository Interface Changes
Changing method signatures, adding new repository methods, etc.

1. Modify the repository interface or implementation in `/src`.
2. Use AI assistance to generate or update the SQL implementation.
3. If the generated SQL conflicts with DDL or other human-maintained references, update the authoritative source first.
4. Run ZTD tests.
5. Regenerate config if SQL output shape changed.

Flow: Interface to SQL to Tests

---

# Workflow C - Starting From Repository SQL Logic Changes
Bug fixes, refactoring, rewriting queries.

1. Edit SQL inside the repository.
2. Run ZTD tests.
3. If intended behavior changes, coordinate any necessary DDL updates before adjusting dependent code.
4. Update fixtures as needed.
5. Regenerate config if result shape changed.

Flow: SQL to Tests

---

# Workflow D - Starting From Optional Reference Adjustments
Updates to informational reference files (domain-specs or enums) that describe existing behavior.

Flow: Reference updates to SQL to Tests to (DDL if required)

---

# Combined Real-World Examples

 - Adding a new contract state:
   DDL (and optional enum documentation) to SQL to config to tests

- Adding a new table:
  DDL to config to SQL to fixtures to tests

- Fixing business logic:
  SQL to tests

ZTD ensures the development always converges into a consistent, validated workflow.

---

# Human Responsibilities

Humans maintain:

- Schema definitions (`ztd/ddl`)
- Repository interfaces and architectural decisions
- Optional reference files (`ztd/domain-specs`, `ztd/enums`) when they exist
- Acceptance and review of AI-generated patches

Humans decide what is correct.

---

# AI Responsibilities

AI must:

- Use DDL as the physical structure constraint and treat domain-specs/enums only as optional documentation when explicitly requested.
- Generate SQL consistent with DDL.
- Update fixtures when needed.
- Never modify `ztd/AGENTS.md` or `ztd/README.md` without explicit instruction.

AI decides how to implement, but not what is correct.

---

# ZTD CLI Responsibilities

ZTD CLI:

- Parses DDL to compute schema shapes
- Rewrites SQL via CTE shadowing for testing
- Generates `ztd-row-map.generated.ts`
- Enables deterministic, parallel SQL unit tests

ZTD is the verification engine that validates correctness beyond static typing.

---

# Summary

This appendix documents how ZTD is used strictly as an internal implementation and maintenance guide.
It does not affect the runtime behavior of the application.
Its purpose is ensuring:

- Schema integrity
- SQL correctness
- Domain consistency
- Reliable AI-assisted development

With ZTD, humans define the meaning, AI writes the implementation, and tests guarantee correctness.
