# Appendix: Development Workflow Using Zero Table Dependency (ZTD)

This application uses **Zero Table Dependency (ZTD)** as an internal development workflow for writing, testing, and maintaining SQL logic.
ZTD is not part of the application's runtime behavior; rather, it provides a framework for:

- Maintaining consistent SQL across the project
- Keeping schema metadata and generated artifacts synchronized
- Ensuring deterministic SQL unit tests
- Enabling structured collaboration between humans and AI

This section documents how ZTD is used inside this repository as a development methodology.

---

## Defaults (important)

- This project adopts **ZTD as the default development and testing methodology**.
- ZTD is assumed unless explicitly stated otherwise.
- Detailed rules about test execution modes are defined in `templates/tests/AGENTS.md`.

---

## Generated files (important)

- `tests/generated/` is auto-generated and must never be committed.
- After cloning the repository (or in a clean environment), run `npx ztd ztd-config`.
- If TypeScript reports missing modules or type errors because `tests/generated/` is missing, run `npx ztd ztd-config`.

---

# Validation tooling (recipes)

- Every generated ZTD workspace includes `@rawsql-ts/sql-contract` plus a validator backend. Use `docs/recipes/sql-contract.md` for the canonical mapping guidance.
- When `@rawsql-ts/sql-contract` and `zod` are declared, follow `docs/recipes/validation-zod.md` (optional helpers such as `@rawsql-ts/sql-contract-zod` expose `reader.zod` and coercion utilities but are not required).
- When `@rawsql-ts/sql-contract` is declared without `zod` but `arktype` is installed, follow `docs/recipes/validation-arktype.md`.

## TypeScript validation (required)

After any code change, TypeScript type checking **must** be performed and must pass.

- Run the project-appropriate typecheck command (e.g. `pnpm typecheck`).
- If generated files are involved, run generators first, then re-run typecheck.
- If typecheck fails, fix errors by root cause, not only the first reported error.
- A change is not considered complete unless typecheck is green.
CI pipelines SHOULD run `npx ztd ztd-config` before typecheck and tests (recommended).

Rationale:  
In ZTD-based development, many schema or SQL inconsistencies surface first as TypeScript errors via generated row maps and DTOs.
Type checking is a primary correctness signal, not an optional step.

---

## ZTD Implementation Guide (src/)

## SQL-First Rules (important)

- All application CRUD MUST be written as `.sql` files.
- TypeScript repositories must only call those SQL files and map params/results.
- Do not implement application CRUD via `writer.insert/update/remove`.
- If a column has a DB default, scaffolding MUST omit assigning a value.
- If a human explicitly defines a parameter for that column, use the parameter.
- If a column has no DB default and no human-defined parameter, scaffolding MUST require a value.
- Never invent values.
- Place CRUD SQL under `src/sql/<table_name>/` using the exact table name.
- Name files `<action>.sql` (e.g., `src/sql/user_account/update_display_name.sql`).
- SQL files MUST use named parameters (e.g., `:user_account_id`).
- Adapters compile named parameters to driver-specific placeholders at runtime.
- Do not write driver-specific placeholders (e.g., `$1`) in SQL files unless explicitly in driver-locked mode.
- Do not set `created_at` / `updated_at` / `deleted_at` in application code.
- Do not inject timestamps (e.g., `new Date()`).
- Do not assume `updated_at` changes on UPDATE unless explicitly defined in SQL or DB triggers.
- SQL expressions (`current_timestamp/now()`, functions, operators, arithmetic, JSON ops) MUST live in `.sql`.
- Never emulate SQL expressions in TypeScript or DSL.
- Repositories stay thin: param shaping, SQL invocation, result mapping only.
- Create reader/writer/executor adapters once per executor and reuse; do not create them inside each repository function.
- Do not default to `RETURNING *`; add explicit returning columns only when needed.
- These rules apply to all work under `src/` and are mirrored in `src/AGENTS.md`.

The `src/` directory should contain pure TypeScript logic that operates on the row interfaces generated by `tests/generated/ztd-row-map.generated.ts`. Tests should import the row map, repositories should import DTOs, and fixtures must stay under `tests/`. Keep production code decoupled from the generated row map to preserve the distinction between implementation and test scaffolding.

### Runtime dependency boundaries (important)

- Code under `src/` MUST NOT import anything from `tests/` or `tests/generated/`.
- Generated row-maps are test-only artifacts and MUST NEVER influence runtime behavior.
- Mapper and writer runtime utilities MUST NOT depend on ZTD internals or generated helpers.
- All schema compatibility checks (column existence, enum coverage, forbidden columns, etc.) MUST be enforced in tests, never in production code.

### Repository Classes: What to Care About

#### Scope and Responsibility
- Repository classes are responsible for executing SQL and returning query results.
- Avoid embedding business logic, thresholds, or data reshaping inside repositories.
- Treat repositories as thin adapters over SQL.

#### Mandatory testing rule (important)

Whenever a repository class is created or modified, corresponding tests **must** be created or updated.

Rules:
- Every public repository method must be covered by tests.
- Tests must call repository methods, not raw SQL files or SQL strings.
- ZTD fixtures are the only allowed source of database state in tests.
- A repository change without tests is considered incomplete.
- Every repository or test modification must be followed by `pnpm --filter <package> test` (replace `<package>` with the template package name).
  - `tests/support/global-setup.ts` now emits a warning when `DATABASE_URL` is missing so you remember to install an adapter or provide a connection before running SQL-backed tests.
  - If the suite fails, fix the root cause and rerun the command until it passes before considering the repository change complete.

Rationale:  
ZTD derives much of its value from deterministic, repository-level tests.
Without tests, schema drift and SQL inconsistencies cannot be detected.

#### SQL Management
- Keep every CRUD and SELECT statement in a dedicated `.sql` file under `src/sql/<table_name>/`.
- Load SQL via `fs.readFileSync` or similar helpers so repositories never embed long SQL strings inline.
- Inline SQL is forbidden unless a human explicitly requests an override; follow the file-based SQL convention by default.
- Repository modules may live under `src/repositories/views/` or `src/repositories/tables/`, but all of them must load SQL from `src/sql/<table_name>/`.

#### Specifications and Documentation
- If a markdown file with the same base name as the repository or SQL exists, read it before implementation.
  - Such files may contain repository-local specifications (e.g. decision tables, thresholds, request/response notes).
  - Naming should be aligned (e.g. `FooRepository.ts`, `foo.sql`, `foo.md`).

#### Request and Response Contracts
- Be explicit about request parameters (types, nullability, constraints).
- Be explicit about response shape (columns, ordering, cardinality).
- Prefer documenting contracts in the repository-local markdown file rather than code comments when they are non-trivial.

### SqlClient lifecycle policy (important)

- When using `src/db/sql-client.ts`, prefer a shared `SqlClient` per worker process (singleton).
- Avoid creating a new database connection for every query or test case.
- Do not share a live connection across parallel workers; each worker should own its own shared client or pool.
- If you need strict isolation, create a dedicated client for that scope and close it explicitly.

### Repository SQL and DTO policy (important)

- Repository SQL must return application-facing DTO shapes.
- SQL SELECT statements should alias columns to camelCase and match the repository return types.
- Do not introduce intermediate `*Row` types when SQL already returns DTO-compatible shapes.
- Define separate Row types only when SQL intentionally returns database-shaped (snake_case) rows, and always convert them explicitly.

---

### SQL-first guardrails (template-specific)

- `src/repositories/views/user-profiles.ts` is the authoritative mapper for the columns defined by the DDL; it MUST enumerate those columns explicitly so downstream logic never infers metadata at runtime.
- `src/repositories/tables/user-accounts.ts` MUST execute SQL from `src/sql/user_account/` and MUST NOT embed SQL strings inline.
- SQL must use named parameters and avoid driver-specific placeholders.
- Do not add inferred semantics or audit column updates in repository code; keep them in SQL or DB triggers.

#### Mapper strictness policy

- Mapping is strict by default: SQL must return exactly the DTO-shaped results that `src/repositories/views/user-profiles.ts` exposes; missing or mismatched columns are bugs that tests MUST surface.
- Non-strict behaviors (coercions, key transforms, etc.) MUST be enabled explicitly via named presets or configuration; relying on implicit or silent defaults is prohibited.

### Sequence / identity column policy (important)

- Sequence / identity columns (auto-generated IDs) are infrastructure concerns.
- Do not explicitly assign values to sequence / identity columns in `INSERT` statements unless explicitly instructed.
- Repository method inputs should omit sequence / identity columns by default.
- Only treat an ID as input data when it represents a business rule (e.g. natural keys, externally assigned IDs).

### No test-driven fallbacks in production code (important)

- Do not add fallbacks in `src/` that exist only to accommodate ZTD/testkit/rewriter limitations.
- If a query fails to be rewritten into ZTD form, do not change runtime behavior to compensate.
- Report tooling issues with minimal reproduction and expected behavior.

Rationale:  
Production code must not diverge from intended SQL semantics due to tooling constraints.

---

## ZTD Test Guide (tests/)

Testing under ZTD follows dedicated, directory-scoped rules.

- Test design, execution mode selection, and constraints are defined in:
  - `templates/tests/AGENTS.md`
- Tests validate repository behavior and returned DTOs.
- Raw SQL files or SQL strings must not be tested directly.

---

# ZTD Directory Layout

```
/ztd
  /ddl
    *.sql               <- physical schema definitions

  README.md             <- documentation for the layout
  AGENTS.md             <- combined guidance for DDL

/src                    <- application & repository logic
  /sql
    /<table_name>        <- CRUD + SELECT SQL (named params)
  /repositories
    /views               <- read-only repositories
    /tables              <- table repositories (SQL-first)
  /jobs                  <- job runners that execute SQL from /sql/<table_name>
/tests                  <- ZTD tests, fixtures, row-maps
```

Only `ztd/ddl` is part of the template contract. Do not create or assume any other `ztd` subdirectories unless the project explicitly adds them.

The file `tests/generated/ztd-layout.generated.ts` ensures ZTD CLI always points to the correct directories.

---

# Protected directories and edit ownership (important)

- DDL editing is human-led: `ztd/ddl/`
- `ztd/ddl` is the sole human-owned directory inside `/ztd`; other directories must not be assumed or created without explicit instructions.
- Application code is shared ownership: `src/`
- Tests are shared ownership: `tests/`
  - Detailed test constraints live in `templates/tests/AGENTS.md`.

Additionally:
- Never modify `ztd/AGENTS.md` or `ztd/README.md` without explicit instruction.
- When changes are required in human-led directories, prefer proposing a patch and explaining the impact before applying it.

---

# Principles of ZTD in This Repository

### 1. Humans own the definitions
- Physical schema (DDL)
- Repository interfaces

### 2. AI assists with implementation
- Generating repository SQL
- Updating fixtures
- Producing intermediate TypeScript structures
- Ensuring SQL adheres to DDL

### 3. ZTD enforces consistency
ZTD tests verify that:
- SQL logic matches DDL shapes

If anything diverges, ZTD failures surface immediately and deterministically.

---

# Development Workflows

Different types of changes start from different entry points. Use the workflow appropriate for your situation.

---

# Workflow A - Starting From DDL Changes
Modifying tables, columns, constraints, indexes.

1. Edit DDL files in `ztd/ddl/`.
2. Run `npx ztd ztd-config`.
3. Update repository SQL to match the new schema.
4. Update fixtures if result shapes changed.
5. Run tests.

Flow: DDL to Repository SQL to Fixtures and Tests to Application

---

# Workflow B - Starting From Repository Interface Changes
Changing method signatures, adding new repository methods, etc.

1. Modify the repository interface or implementation in `/src`.
2. Use AI assistance to generate or update the SQL implementation.
3. If the generated SQL conflicts with DDL or other human-maintained references, update the authoritative source first.
4. Run ZTD tests.
5. Regenerate config if SQL output shape changed.

Flow: Interface to SQL to Tests

---

# Workflow C - Starting From Repository SQL Logic Changes
Bug fixes, refactoring, rewriting queries.

1. Edit SQL inside the repository.
2. Run ZTD tests.
3. If intended behavior changes, coordinate any necessary DDL updates before adjusting dependent code.
4. Update fixtures as needed.
5. Regenerate config if result shape changed.

Flow: SQL to Tests

---

# Combined Real-World Examples

- Adding a new contract state: DDL to SQL to config to tests
- Adding a new table: DDL to SQL to fixtures/tests
- Fixing business logic: SQL to tests

ZTD ensures the development always converges into a consistent, validated workflow.

---

# Human Responsibilities

Humans maintain:

- Schema definitions (`ztd/ddl`)
- Repository interfaces and architectural decisions
- Acceptance and review of AI-generated patches

Humans decide what is correct.

---

# AI Responsibilities

AI must:

- Use DDL as the physical structure constraint and never assume any additional `ztd` directories exist unless explicitly added.
- Generate SQL consistent with DDL.
- Update fixtures when needed.
- Never modify `ztd/AGENTS.md` or `ztd/README.md` without explicit instruction.

AI decides how to implement, but not what is correct.

---

# ZTD CLI Responsibilities

ZTD CLI:

- Parses DDL to compute schema shapes
- Rewrites SQL via CTE shadowing for testing
- Generates `ztd-row-map.generated.ts`
- Enables deterministic, parallel SQL unit tests

ZTD is the verification engine that validates correctness beyond static typing.

---

# Summary

This appendix documents how ZTD is used strictly as an internal implementation and maintenance guide.
It does not affect the runtime behavior of the application.
Its purpose is ensuring:

- Schema integrity
- SQL correctness
- Domain consistency
- Reliable AI-assisted development

With ZTD, humans define the meaning, AI writes the implementation, and tests guarantee correctness.
