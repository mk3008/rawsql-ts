# @rawsql-ts/cli

## Overview
@rawsql-ts/cli is the schema and entity management companion for the rawsql-ts ecosystem.  
Its mission is to streamline the **DDL -> Entity -> Repository -> ZTD Test** development loop, making it predictable, automation-friendly, and easy for AI assistants to navigate.  
The CLI is a development-time tool only and is never required at runtime.

The CLI **never writes to a database**.  
It only *reads* schema definitions, generates models, and computes diffs. This keeps workflows aligned with **Zero Table Dependency (ZTD)**, where tests use a real Postgres engine while respecting a read-only schema surface.

## Zero Table Dependency Summary
Tests execute against a real Postgres engine, but CRUD statements are rewritten into fixture-backed SELECT queries before they are sent, so no physical tables are ever read or written.  
This makes the workflow deterministic, repeatable, and safe for AI-assisted development.

## Installation

Install the CLI into your project (recommended for most users):

```bash
npm install -D @rawsql-ts/cli
```

Then run the CLI:

```bash
npx rawsql-ts
```

If you are developing inside the rawsql-ts monorepo (pnpm workspace), use:

```bash
pnpm --filter @rawsql-ts/cli exec rawsql-ts
```

`ddl pull` requires Postgres tooling such as `pg_dump` installed locally.

## Commands

### `init`

Run `rawsql-ts init` to bootstrap an interactive ZTD workspace.  
The wizard walks through two workflows, prompts for a database connection when needed, protects existing files unless you confirm, and emits the baseline artifacts listed below:

- `ddl/schema.sql`  
- `tests/ztd-config.ts`  
- `README-ZTD.md`, `src/ZTD-GUIDE.md`, `tests/ZTD-TEST-GUIDE.md`

Each artifact serves a specific role:

- `ddl/schema.sql`: the canonical DDL that defines tables, indexes, and constraints before fixtures are generated.
- `tests/ztd-config.ts`: the autogenerated TestRowMap that describes every table row shape for ZTD tests and repositories.
- `README-ZTD.md`: a human-readable description of Zero Table Dependency and why the project chooses safe, fixture-backed tests.
- `src/ZTD-GUIDE.md`: guidance for application-layer coding that never issues migrations or direct inserts.
- `tests/ZTD-TEST-GUIDE.md`: instructions that explain how ZTD rewrites INSERT/UPDATE/DELETE into fixture-backed selects and how the generated row types should inform AI-generated tests.

The wizard generates `tests/ztd-config.ts` because both AI assistants and your repository layer need a deterministic, test-only contract for every table. Provide `ddl/` as the schema source and `tests/ztd-config.ts` as the row-type map, and downstream tools can produce repositories, validation logic, and ZTD tests without guessing column metadata.

### `ztd-config`

```bash
rawsql-ts ztd-config --ddl-dir ddl --extensions .sql --out tests/ztd-config.ts
```

This command parses every `CREATE TABLE` in the configured DDL sources and emits a test-only row map that lives under `tests/`. The exported module includes warnings that remind engineers not to import it from `src`.

#### Watch mode

```bash
rawsql-ts ztd-config --watch --ddl-dir ddl --extensions .sql --out tests/ztd-config.ts
```

Watch mode monitors `ddl/**/*.sql`, regenerates `tests/ztd-config.ts` whenever the DDL changes, and only touches the row map (never fixtures or `src/`). It logs:

```text
[watch] DDL changed: ddl/public.example.sql
[watch] Updated: tests/ztd-config.ts
```

Keeping `rawsql ztd-config --watch` running keeps the row map in lockstep with the DDL while you edit.

### `ddl pull`

```bash
rawsql-ts ddl pull --url postgres://user@host/db --out ddl/
```

### `ddl diff`

```bash
rawsql-ts ddl diff --ddl-dir ddl --url postgres://user@host/db --out plan.diff
```

The diff is normalized and deterministic, so `plan.diff` can safely stay in version control. It compares canonicalized DDL rather than engine-specific formatting, making reviews stable for both humans and AI.

```diff
@@ -1,3 +1,3 @@
-CREATE TABLE public.sessions (id serial PRIMARY KEY);
+CREATE TABLE public.sessions (id bigint PRIMARY KEY);
```

Track each `plan.diff` alongside your schema updates so the diff history mirrors your intended changes.

## DDL Directory Layout

Place your DDL files in the `ddl/` directory. The CLI scans this directory recursively, so you can organize tables by domain, feature, or area. `ddl/` may contain multiple `.sql` files, and nested subdirectories are picked up automatically. We recommend "one table per file" so entity generation and code review stay predictable.

## Example Generated Test Row Map

After running `rawsql-ts ztd-config`, `tests/ztd-config.ts` emits every table interface and a `TestRowMap` that AI assistants can inspect to learn row shapes. The file starts with strong warnings to prevent production imports:

```ts
// ZTD TEST ROW TYPES ? AUTO GENERATED
// DO NOT import this file from src.
// Test-only. Not domain entities.
// Synchronized with DDL via ztd-config generator.

export interface TestRowMap {
  'public.users': PublicUsersTestRow;
}

export interface PublicUsersTestRow {
  id: number;
  name: string;
  created_at: string;
}
```

## Development Scenarios

## Scenario A: You already have a database

### Step 1. Pull schema
```bash
rawsql-ts ddl pull --url postgres://user@host/db --out ddl/
```

### Step 2. Generate the ZTD row map
```bash
rawsql-ts ztd-config --ddl-dir ddl --out tests/ztd-config.ts
```

### Step 3. Kick off AI-powered coding
Give your AI both:
- `ddl/*.sql`
- `tests/ztd-config.ts`

This enables:
- repository generation  
- DTO inference  
- validation logic  
- CRUD code matching your schema

### Step 4. Ask AI to produce tests
AI uses entity interfaces to build validation-safe ZTD tests.

### Step 5. Run ZTD tests
Tests execute against a real Postgres engine but CRUD queries are rewritten into **fixture-backed SELECT rewrites**.

### Step 6. Fix issues and iterate
Update DDL -> regenerate the row map -> rerun tests (or keep `rawsql ztd-config --watch` running while editing DDL).

## Scenario B: No existing database (DDL-first)

### Step 1. Write DDL
Create `ddl/schema.sql` by hand.

### Step 2. Generate the ZTD row map
```bash
rawsql-ts ztd-config --ddl-dir ddl --out tests/ztd-config.ts
```

### Step 3. AI coding
Provide DDL + entities so the AI can generate repositories and domain logic.

### Step 4. AI creates ZTD tests
AI uses entity definitions to understand fixtures + expected row shapes.

### Step 5. Execute ZTD tests
Run your test suite with pg-testkit.

### Step 6. Iterate until stable
Refine schema + logic based on test failures.

## How It Works

1. **DDL parsing**  
   rawsql-ts parses `CREATE TABLE` statements into ASTs for strict interpretation.

2. **ZTD row map generation**  
   `rawsql ztd-config` converts SQL types into TypeScript while preserving nullability and primary-key semantics, and it prepends warnings so the output stays test-only.

3. **Schema diff**  
   `ddl diff` normalizes SQL before comparing with `pg_dump` output.

4. **ZTD execution**  
   Tests using pg-testkit rewrite all writes (INSERT/UPDATE/DELETE) into safe SELECT queries.

## Best Practices

- Always version-control your DDL files.  
- Regenerate entity models whenever the schema changes.  
- Keep DDL small and modular (one file per table where possible).  
- Never import CLI code inside your application runtime.  
- Ensure AI assistants read from both `ddl/` for the schema and `tests/ztd-config.ts` for the row types, since these two sources fully define the repository-layer contract.

## ZTD Troubleshooting

### Case A – ZTD tests pass but production code fails
**Cause:** The DDL definitions and the physical database are out of sync (missing columns, different types, absent constraints).  
**Action:** Run `rawsql-ts ddl diff --ddl-dir ddl --url <db> --out plan.diff`, review the generated diff, and apply migrations to align the live schema with the authoritative DDL.

### Case B – TypeScript compiles but ZTD tests fail
**Cause:** `tests/ztd-config.ts` is stale or fixtures lack the newly added columns from the updated DDL.  
**Action:** Rerun `rawsql ztd-config` to refresh the row map (or rely on `rawsql ztd-config --watch`), update the fixtures, then rerun the tests to observe failing columns.

### Case C – Everything drifted apart
DDL → ZTD row map → fixtures → `src` are no longer aligned.  
**Action:** 1. Regenerate `tests/ztd-config.ts` via `rawsql ztd-config`.  2. Update fixtures to match the new columns.  3. Adjust the domain model in `src/` if business rules changed.  4. Run `ddl diff` and apply migrations if necessary.

## Notes

- Postgres only (because of `pg_dump`)  
- Entity generation is DB-agnostic if DDL follows Postgres syntax  
- CLI and testkit are complementary but decoupled  

This README is explicitly AI-friendly: `ddl/` and `tests/ztd-config.ts` together describe the schema and row-type contract that downstream code should consume.
