import { SqlTokenizer } from "./SqlTokenizer";
import { SelectQueryParser } from "./SelectQueryParser";
import {
    CreateTableQuery,
    TableColumnDefinition,
    TableConstraintDefinition,
    ColumnConstraintDefinition,
    ReferenceDefinition,
    ColumnConstraintKind,
    TableConstraintKind,
    ReferentialAction,
    ConstraintDeferrability,
    ConstraintInitially,
    MatchType
} from "../models/CreateTableQuery";
import { Lexeme, TokenType } from "../models/Lexeme";
import { FullNameParser } from "./FullNameParser";
import type { SelectQuery } from "../models/SelectQuery";
import { FunctionExpressionParser } from "./FunctionExpressionParser";
import { ValueParser } from "./ValueParser";
import { IdentifierString, RawString, TypeValue, ValueComponent, QualifiedName } from "../models/ValueComponent";
import { joinLexemeValues } from "../utils/ParserStringUtils";

interface QualifiedNameResult {
    namespaces: string[] | null;
    name: IdentifierString;
    newIndex: number;
}

interface ColumnParseResult {
    value: TableColumnDefinition;
    newIndex: number;
}

interface TableConstraintParseResult {
    value: TableConstraintDefinition;
    newIndex: number;
}

interface ReferenceParseResult {
    value: ReferenceDefinition;
    newIndex: number;
}

/**
 * Parses CREATE TABLE statements (DDL or AS SELECT) into CreateTableQuery models.
 */
export class CreateTableParser {
    private static readonly TABLE_CONSTRAINT_STARTERS = new Set([
        "constraint",
        "primary key",
        "unique",
        "unique key",
        "foreign key",
        "check"
    ]);

    private static readonly COLUMN_CONSTRAINT_STARTERS = new Set([
        "constraint",
        "not null",
        "null",
        "default",
        "primary key",
        "unique",
        "unique key",
        "references",
        "check",
        "generated always",
        "generated always as identity",
        "generated by default",
        "generated by default as identity"
    ]);

    private static readonly MATCH_KEYWORDS = new Map<string, MatchType>([
        ["match full", "full"],
        ["match partial", "partial"],
        ["match simple", "simple"]
    ]);

    private static readonly REFERENTIAL_ACTIONS = new Map<string, ReferentialAction>([
        ["cascade", "cascade"],
        ["restrict", "restrict"],
        ["no action", "no action"],
        ["set null", "set null"],
        ["set default", "set default"]
    ]);

    private static readonly DEFERRABILITY_KEYWORDS = new Map<string, ConstraintDeferrability>([
        ["deferrable", "deferrable"],
        ["not deferrable", "not deferrable"]
    ]);

    private static readonly INITIALLY_KEYWORDS = new Map<string, ConstraintInitially>([
        ["initially immediate", "immediate"],
        ["initially deferred", "deferred"]
    ]);

    /**
     * Parse SQL string to CreateTableQuery AST.
     */
    public static parse(query: string): CreateTableQuery {
        const tokenizer = new SqlTokenizer(query);
        const lexemes = tokenizer.readLexemes();
        const result = this.parseFromLexeme(lexemes, 0);
        if (result.newIndex < lexemes.length) {
            throw new Error(`Syntax error: Unexpected token "${lexemes[result.newIndex].value}" at position ${result.newIndex}. The CREATE TABLE statement is complete but there are additional tokens.`);
        }
        return result.value;
    }

    /**
     * Parse from lexeme array (for internal use and tests).
     */
    public static parseFromLexeme(lexemes: Lexeme[], index: number): { value: CreateTableQuery; newIndex: number } {
        let idx = index;

        // Guard against unexpected end of input before parsing begins.
        if (idx >= lexemes.length) {
            throw new Error(`[CreateTableParser] Unexpected end of input at position ${idx}.`);
        }

        const commandToken = lexemes[idx].value.toLowerCase();
        const isTemporary = commandToken === "create temporary table";

        if (commandToken !== "create table" && !isTemporary) {
            throw new Error(`[CreateTableParser] Syntax error at position ${idx}: expected 'CREATE TABLE' but found '${lexemes[idx].value}'.`);
        }
        idx++;

        // Handle optional IF NOT EXISTS clause.
        const tokenAt = (offset: number) => lexemes[idx + offset]?.value.toLowerCase();
        let ifNotExists = false;
        if (tokenAt(0) === "if not exists") {
            idx++;
            ifNotExists = true;
        }

        // Parse qualified table name.
        const tableNameResult = this.parseQualifiedName(lexemes, idx);
        idx = tableNameResult.newIndex;
        const tableName = tableNameResult.name;
        const tableNamespaces = tableNameResult.namespaces;

        // Place captured comments from the identifier on the CreateTableQuery after instantiation.
        const positionedComments = tableName.positionedComments ? [...tableName.positionedComments] : null;
        const legacyComments = tableName.comments ? [...tableName.comments] : null;

        let columns: TableColumnDefinition[] = [];
        let tableConstraints: TableConstraintDefinition[] = [];
        let tableOptions: RawString | null = null;
        let asSelectQuery: SelectQuery | undefined;

        // Parse DDL column definitions when present.
        if (lexemes[idx]?.type === TokenType.OpenParen) {
            ({ columns, tableConstraints, newIndex: idx } = this.parseDefinitionList(lexemes, idx));
        }

        // Capture trailing table options that appear before an AS SELECT clause.
        if (idx < lexemes.length) {
            const nextValue = tokenAt(0);
            if (!this.isSelectKeyword(nextValue, lexemes[idx + 1])) {
                const optionsEnd = this.findClauseBoundary(lexemes, idx);
                if (optionsEnd > idx) {
                    tableOptions = new RawString(joinLexemeValues(lexemes, idx, optionsEnd));
                    idx = optionsEnd;
                }
            }
        }

        // Parse optional AS SELECT / SELECT clause.
        const nextToken = tokenAt(0);
        if (nextToken === "as") {
            idx++;
            const selectResult = SelectQueryParser.parseFromLexeme(lexemes, idx);
            asSelectQuery = selectResult.value;
            idx = selectResult.newIndex;
        } else if (nextToken === "select" || nextToken === "with" || nextToken === "values") {
            const selectResult = SelectQueryParser.parseFromLexeme(lexemes, idx);
            asSelectQuery = selectResult.value;
            idx = selectResult.newIndex;
        }

        const query = new CreateTableQuery({
            tableName: tableName.name,
            namespaces: tableNamespaces,
            isTemporary,
            ifNotExists,
            columns,
            tableConstraints,
            tableOptions,
            asSelectQuery
        });

        // Re-attach positioned comments captured on the identifier.
        if (positionedComments) {
            query.tableName.positionedComments = positionedComments.map(pc => ({
                position: pc.position,
                comments: [...pc.comments]
            }));
        }
        if (legacyComments) {
            query.tableName.comments = [...legacyComments];
        }

        return { value: query, newIndex: idx };
    }

    private static parseQualifiedName(lexemes: Lexeme[], index: number): QualifiedNameResult {
        const { namespaces, name, newIndex } = FullNameParser.parseFromLexeme(lexemes, index);
        return {
            namespaces: namespaces ? [...namespaces] : null,
            name,
            newIndex
        };
    }

    private static parseDefinitionList(
        lexemes: Lexeme[],
        index: number
    ): { columns: TableColumnDefinition[]; tableConstraints: TableConstraintDefinition[]; newIndex: number } {
        let idx = index;
        const columns: TableColumnDefinition[] = [];
        const constraints: TableConstraintDefinition[] = [];

        // Skip opening parenthesis.
        idx++;

        // Parse individual column or constraint entries until closing parenthesis.
        while (idx < lexemes.length) {
            const lexeme = lexemes[idx];
            if (lexeme.type === TokenType.CloseParen) {
                idx++;
                break;
            }

            const tokenValue = lexeme.value.toLowerCase();

            if (this.TABLE_CONSTRAINT_STARTERS.has(tokenValue)) {
                const constraintResult = this.parseTableConstraint(lexemes, idx);
                constraints.push(constraintResult.value);
                idx = constraintResult.newIndex;
            } else {
                const columnResult = this.parseColumnDefinition(lexemes, idx);
                columns.push(columnResult.value);
                idx = columnResult.newIndex;
            }

            // Consume delimiter comma between definitions.
            if (idx < lexemes.length && (lexemes[idx].type & TokenType.Comma)) {
                idx++;
                continue;
            }

            // Break when encountering the closing parenthesis.
            if (idx < lexemes.length && lexemes[idx].type === TokenType.CloseParen) {
                idx++;
                break;
            }
        }

        return { columns, tableConstraints: constraints, newIndex: idx };
    }

    private static parseColumnDefinition(lexemes: Lexeme[], index: number): ColumnParseResult {
        let idx = index;

        // Parse the column name as a qualified identifier.
        const columnNameResult = this.parseQualifiedName(lexemes, idx);
        idx = columnNameResult.newIndex;
        if (columnNameResult.namespaces && columnNameResult.namespaces.length > 0) {
            const qualified = [...columnNameResult.namespaces, columnNameResult.name.name].join(".");
            throw new Error(`[CreateTableParser] Column name '${qualified}' must not include a schema or namespace qualifier.`);
        }
        const columnName = columnNameResult.name;

        // Parse optional data type immediately following the column name.
        let dataType: TypeValue | RawString | undefined;
        if (idx < lexemes.length && !this.isColumnConstraintStart(lexemes[idx]) && !this.isColumnTerminator(lexemes[idx])) {
            const typeResult = this.parseColumnType(lexemes, idx);
            dataType = typeResult.value;
            idx = typeResult.newIndex;
        }

        // Collect column constraints until termination.
        const constraints: ColumnConstraintDefinition[] = [];
        while (idx < lexemes.length && !this.isColumnTerminator(lexemes[idx])) {
            const constraintResult = this.parseColumnConstraint(lexemes, idx);
            constraints.push(constraintResult.value);
            idx = constraintResult.newIndex;
        }

        const columnDef = new TableColumnDefinition({
            name: columnName,
            dataType,
            constraints
        });

        return { value: columnDef, newIndex: idx };
    }

    private static parseColumnType(lexemes: Lexeme[], index: number): { value: TypeValue | RawString; newIndex: number } {
        try {
            const result = FunctionExpressionParser.parseTypeValue(lexemes, index);
            return { value: result.value, newIndex: result.newIndex };
        } catch {
            const typeEnd = this.findFirstConstraintIndex(lexemes, index);
            const rawText = joinLexemeValues(lexemes, index, typeEnd);
            return { value: new RawString(rawText), newIndex: typeEnd };
        }
    }

    private static parseColumnConstraint(lexemes: Lexeme[], index: number): { value: ColumnConstraintDefinition; newIndex: number } {
        let idx = index;
        let constraintName: IdentifierString | undefined;

        // Handle optional CONSTRAINT <name> prefix.
        if (lexemes[idx]?.value.toLowerCase() === "constraint") {
            idx++;
            const nameResult = this.parseQualifiedName(lexemes, idx);
            constraintName = nameResult.name;
            idx = nameResult.newIndex;
        }

        const token = lexemes[idx];
        if (!token) {
            throw new Error(`[CreateTableParser] Expected constraint definition at index ${idx}.`);
        }
        const value = token.value.toLowerCase();

        // Parse NOT NULL / NULL constraints.
        if (value === "not null" || value === "null") {
            idx++;
            return {
                value: new ColumnConstraintDefinition({
                    kind: value === "not null" ? "not-null" : "null",
                    constraintName
                }),
                newIndex: idx
            };
        }

        // Parse DEFAULT constraint with arbitrary expressions.
        if (value === "default") {
            idx++;
            const exprResult = ValueParser.parseFromLexeme(lexemes, idx);
            idx = exprResult.newIndex;
            return {
                value: new ColumnConstraintDefinition({
                    kind: "default",
                    constraintName,
                    defaultValue: exprResult.value
                }),
                newIndex: idx
            };
        }

        // Parse PRIMARY KEY constraint.
        if (value === "primary key") {
            idx++;
            return {
                value: new ColumnConstraintDefinition({
                    kind: "primary-key",
                    constraintName
                }),
                newIndex: idx
            };
        }

        // Parse UNIQUE / UNIQUE KEY constraint.
        if (value === "unique" || value === "unique key") {
            idx++;
            return {
                value: new ColumnConstraintDefinition({
                    kind: "unique",
                    constraintName
                }),
                newIndex: idx
            };
        }

        // Parse REFERENCES clause.
        if (value === "references") {
            const referenceResult = this.parseReferenceDefinition(lexemes, idx);
            idx = referenceResult.newIndex;
            return {
                value: new ColumnConstraintDefinition({
                    kind: "references",
                    constraintName,
                    reference: referenceResult.value
                }),
                newIndex: idx
            };
        }

        // Parse CHECK constraint.
        if (value === "check") {
            idx++;
            const checkExpression = this.parseParenExpression(lexemes, idx);
            idx = checkExpression.newIndex;
            return {
                value: new ColumnConstraintDefinition({
                    kind: "check",
                    constraintName,
                    checkExpression: checkExpression.value
                }),
                newIndex: idx
            };
        }

        // Parse identity-style generated clauses.
        if (value.startsWith("generated")) {
            const clauseEnd = this.findFirstConstraintIndex(lexemes, idx + 1);
            const text = joinLexemeValues(lexemes, idx, clauseEnd);
            idx = clauseEnd;
            const kind: ColumnConstraintKind = value.startsWith("generated always")
                ? "generated-always-identity"
                : "generated-by-default-identity";
            return {
                value: new ColumnConstraintDefinition({
                    kind,
                    constraintName,
                    rawClause: new RawString(text)
                }),
                newIndex: idx
            };
        }

        // Fallback to raw clause capture for unsupported constraints.
        const rawEnd = this.findFirstConstraintIndex(lexemes, idx + 1);
        const rawText = joinLexemeValues(lexemes, idx, rawEnd);
        return {
            value: new ColumnConstraintDefinition({
                kind: "raw",
                constraintName,
                rawClause: new RawString(rawText)
            }),
            newIndex: rawEnd
        };
    }

    private static parseTableConstraint(lexemes: Lexeme[], index: number): TableConstraintParseResult {
        let idx = index;
        let constraintName: IdentifierString | undefined;

        // Capture optional CONSTRAINT <name> prefix.
        if (lexemes[idx]?.value.toLowerCase() === "constraint") {
            idx++;
            const nameResult = this.parseQualifiedName(lexemes, idx);
            constraintName = nameResult.name;
            idx = nameResult.newIndex;
        }

        const token = lexemes[idx];
        if (!token) {
            throw new Error(`[CreateTableParser] Expected table constraint at index ${idx}.`);
        }

        const value = token.value.toLowerCase();

        if (value === "primary key") {
            idx++;
            const { identifiers, newIndex } = this.parseIdentifierList(lexemes, idx);
            idx = newIndex;
            return {
                value: new TableConstraintDefinition({
                    kind: "primary-key",
                    constraintName,
                    columns: identifiers
                }),
                newIndex: idx
            };
        }

        if (value === "unique" || value === "unique key") {
            idx++;
            let inlineKeyName: IdentifierString | undefined;
            if (idx < lexemes.length &&
                lexemes[idx].value !== "(" &&
                !(lexemes[idx].type & TokenType.Command)) {
                const inlineNameResult = this.parseQualifiedName(lexemes, idx);
                inlineKeyName = inlineNameResult.name;
                idx = inlineNameResult.newIndex;
            }
            const { identifiers, newIndex } = this.parseIdentifierList(lexemes, idx);
            idx = newIndex;
            return {
                value: new TableConstraintDefinition({
                    kind: "unique",
                    constraintName: constraintName ?? inlineKeyName,
                    columns: identifiers
                }),
                newIndex: idx
            };
        }

        if (value === "foreign key") {
            idx++;
            let inlineKeyName: IdentifierString | undefined;
            if (idx < lexemes.length &&
                lexemes[idx].value !== "(" &&
                !(lexemes[idx].type & TokenType.Command)) {
                const inlineNameResult = this.parseQualifiedName(lexemes, idx);
                inlineKeyName = inlineNameResult.name;
                idx = inlineNameResult.newIndex;
            }
            const { identifiers, newIndex } = this.parseIdentifierList(lexemes, idx);
            idx = newIndex;
            const referenceResult = this.parseReferenceDefinition(lexemes, idx);
            idx = referenceResult.newIndex;
            return {
                value: new TableConstraintDefinition({
                    kind: "foreign-key",
                    constraintName: constraintName ?? inlineKeyName,
                    columns: identifiers,
                    reference: referenceResult.value,
                    deferrable: referenceResult.value.deferrable,
                    initially: referenceResult.value.initially
                }),
                newIndex: idx
            };
        }

        if (value === "check") {
            idx++;
            const checkExpression = this.parseParenExpression(lexemes, idx);
            idx = checkExpression.newIndex;
            return {
                value: new TableConstraintDefinition({
                    kind: "check",
                    constraintName,
                    checkExpression: checkExpression.value
                }),
                newIndex: idx
            };
        }

        // Fallback to capturing the raw text when the constraint is not recognized.
        const rawEnd = this.findFirstConstraintIndex(lexemes, idx + 1);
        const rawText = joinLexemeValues(lexemes, idx, rawEnd);
        return {
            value: new TableConstraintDefinition({
                kind: "raw",
                constraintName,
                rawClause: new RawString(rawText)
            }),
            newIndex: rawEnd
        };
    }

    private static parseIdentifierList(lexemes: Lexeme[], index: number): { identifiers: IdentifierString[]; newIndex: number } {
        let idx = index;
        const identifiers: IdentifierString[] = [];

        if (lexemes[idx]?.type !== TokenType.OpenParen) {
            throw new Error(`[CreateTableParser] Expected '(' to start identifier list at index ${idx}.`);
        }
        idx++;

        while (idx < lexemes.length) {
            const nameResult = this.parseQualifiedName(lexemes, idx);
            identifiers.push(nameResult.name);
            idx = nameResult.newIndex;

            if (lexemes[idx]?.type === TokenType.Comma) {
                idx++;
                continue;
            }

            if (lexemes[idx]?.type === TokenType.CloseParen) {
                idx++;
                break;
            }
        }

        return { identifiers, newIndex: idx };
    }

    private static parseReferenceDefinition(lexemes: Lexeme[], index: number): ReferenceParseResult {
        let idx = index;

        if (lexemes[idx]?.value.toLowerCase() !== "references") {
            throw new Error(`[CreateTableParser] Expected REFERENCES clause at index ${idx}.`);
        }
        idx++;

        const tableNameResult = this.parseQualifiedName(lexemes, idx);
        idx = tableNameResult.newIndex;
        const targetTable = new QualifiedName(tableNameResult.namespaces, tableNameResult.name);

        // Parse optional column list in the REFERENCES clause.
        let columns: IdentifierString[] | null = null;
        if (lexemes[idx]?.type === TokenType.OpenParen) {
            const listResult = this.parseIdentifierList(lexemes, idx);
            columns = listResult.identifiers;
            idx = listResult.newIndex;
        }

        let matchType: MatchType = null;
        let onDelete: ReferentialAction | null = null;
        let onUpdate: ReferentialAction | null = null;
        let deferrable: ConstraintDeferrability = null;
        let initially: ConstraintInitially = null;

        // Parse optional trailing reference options.
        while (idx < lexemes.length) {
            const current = lexemes[idx].value.toLowerCase();

            if (this.MATCH_KEYWORDS.has(current)) {
                matchType = this.MATCH_KEYWORDS.get(current)!;
                idx++;
                continue;
            }

            if (current === "match") {
                idx++;
                const descriptor = lexemes[idx]?.value.toLowerCase() ?? "";
                matchType = descriptor as MatchType;
                idx++;
                continue;
            }

            if (current === "on delete") {
                idx++;
                const action = lexemes[idx]?.value.toLowerCase() ?? "";
                onDelete = this.REFERENTIAL_ACTIONS.get(action) ?? null;
                idx++;
                continue;
            }

            if (current === "on update") {
                idx++;
                const action = lexemes[idx]?.value.toLowerCase() ?? "";
                onUpdate = this.REFERENTIAL_ACTIONS.get(action) ?? null;
                idx++;
                continue;
            }

            if (this.DEFERRABILITY_KEYWORDS.has(current)) {
                deferrable = this.DEFERRABILITY_KEYWORDS.get(current)!;
                idx++;
                continue;
            }

            if (this.INITIALLY_KEYWORDS.has(current)) {
                initially = this.INITIALLY_KEYWORDS.get(current)!;
                idx++;
                continue;
            }

            break;
        }

        return {
            value: new ReferenceDefinition({
                targetTable,
                columns,
                matchType,
                onDelete,
                onUpdate,
                deferrable,
                initially
            }),
            newIndex: idx
        };
    }

    private static parseParenExpression(lexemes: Lexeme[], index: number): { value: ValueComponent; newIndex: number } {
        let idx = index;
        if (lexemes[idx]?.type !== TokenType.OpenParen) {
            throw new Error(`[CreateTableParser] Expected '(' introducing expression at index ${idx}.`);
        }
        idx++;
        const expressionResult = ValueParser.parseFromLexeme(lexemes, idx);
        idx = expressionResult.newIndex;
        if (lexemes[idx]?.type !== TokenType.CloseParen) {
            throw new Error(`[CreateTableParser] Expected ')' terminating expression at index ${idx}.`);
        }
        idx++;
        return { value: expressionResult.value, newIndex: idx };
    }

    private static isColumnConstraintStart(lexeme: Lexeme | undefined): boolean {
        if (!lexeme) {
            return false;
        }
        const lower = lexeme.value.toLowerCase();
        return this.COLUMN_CONSTRAINT_STARTERS.has(lower);
    }

    private static isColumnTerminator(lexeme: Lexeme | undefined): boolean {
        if (!lexeme) {
            return true;
        }
        if (lexeme.type & (TokenType.Comma | TokenType.CloseParen)) {
            return true;
        }
        return false;
    }

    private static isSelectKeyword(value: string | undefined, nextLexeme?: Lexeme): boolean {
        if (!value) {
            return false;
        }
        if (value === 'with' && nextLexeme?.type === TokenType.OpenParen) {
            return false;
        }
        return value === "as" || value === "select" || value === "with" || value === "values";
    }

    private static findClauseBoundary(lexemes: Lexeme[], index: number): number {
        let idx = index;
        while (idx < lexemes.length) {
            const lower = lexemes[idx].value.toLowerCase();
            if (this.isSelectKeyword(lower, lexemes[idx + 1])) {
                break;
            }
            idx++;
        }
        return idx;
    }

    private static findFirstConstraintIndex(lexemes: Lexeme[], index: number): number {
        let idx = index;
        while (idx < lexemes.length && !this.isColumnConstraintStart(lexemes[idx]) && !this.isColumnTerminator(lexemes[idx])) {
            idx++;
        }
        return idx;
    }

}
