import { CommonTable } from "../models/Clause";
import { SimpleSelectQuery } from "../models/SimpleSelectQuery";
import { CTEDependencyAnalyzer, CTENode } from "./CTEDependencyAnalyzer";
import { CTECollector } from "./CTECollector";
import { SqlFormatter, PresetName, WithClauseStyle } from "./SqlFormatter";
import { CommaBreakStyle, AndBreakStyle } from "./SqlPrinter";
import { IndentCharOption, NewlineOption } from "./LinePrinter";
import { CommentEditor } from "../utils/CommentEditor";
import { SelectQueryParser } from "../parsers/SelectQueryParser";

/**
 * Interface representing a decomposed CTE with executable query
 */
export interface DecomposedCTE {
    name: string;
    query: string;
    dependencies: string[];
    dependents: string[];
    isRecursive: boolean;
}

/**
 * Options for CTEQueryDecomposer formatting
 */
export interface CTEDecomposerOptions {
    preset?: PresetName;
    identifierEscape?: { start: string; end: string };
    parameterSymbol?: string | { start: string; end: string };
    parameterStyle?: 'anonymous' | 'indexed' | 'named';
    indentSize?: number;
    indentChar?: IndentCharOption;
    newline?: NewlineOption;
    keywordCase?: 'none' | 'upper' | 'lower';
    commaBreak?: CommaBreakStyle;
    andBreak?: AndBreakStyle;
    exportComment?: boolean;
    strictCommentPlacement?: boolean;
    withClauseStyle?: WithClauseStyle;
    addComments?: boolean; // Add comments to decomposed queries
}

/**
 * Decomposes complex CTEs into executable standalone queries
 * Supports recursive CTEs, chained dependencies, and circular dependency detection
 */
export class CTEQueryDecomposer {
    private static readonly ERROR_MESSAGES = {
        CIRCULAR_REFERENCE: "Circular reference detected in non-recursive CTEs",
        PARSING_FAILED: "Failed to parse query for comment injection"
    } as const;

    private static readonly COMMENT_TEXTS = {
        AUTO_GENERATED: "Auto-generated by CTE decomposer",
        ORIGINAL_CTE: "Original CTE:",
        DEPENDENCIES: "Dependencies:",
        DEPENDENTS: "Dependents:",
        RECURSIVE_TYPE: "Type: Recursive CTE",
        NONE: "none"
    } as const;

    private readonly dependencyAnalyzer: CTEDependencyAnalyzer;
    private readonly cteCollector: CTECollector;
    private readonly formatter: SqlFormatter;
    private readonly options: CTEDecomposerOptions;

    constructor(options: CTEDecomposerOptions = {}) {
        this.options = options;
        this.dependencyAnalyzer = new CTEDependencyAnalyzer();
        this.cteCollector = new CTECollector();
        this.formatter = new SqlFormatter(options);
    }

    /**
     * Decomposes CTEs in a query into executable standalone queries
     * @param query The query containing CTEs to decompose
     * @returns Array of decomposed CTEs with executable queries
     * @throws Error if circular dependencies are detected in non-recursive CTEs
     */
    public decompose(query: SimpleSelectQuery): DecomposedCTE[] {
        const ctes = this.cteCollector.collect(query);
        if (ctes.length === 0) {
            return [];
        }

        const recursiveCTEs = this.findRecursiveCTEs(query, ctes);
        const dependencyGraph = this.dependencyAnalyzer.analyzeDependencies(query);
        
        this.validateCircularDependencies(recursiveCTEs.length > 0);

        return this.processCTENodes(query, dependencyGraph.nodes, recursiveCTEs);
    }

    /**
     * Validates circular dependencies for non-recursive CTEs
     * @param hasRecursiveCTEs Whether the query contains recursive CTEs
     * @throws Error if circular dependencies exist in non-recursive CTEs
     */
    private validateCircularDependencies(hasRecursiveCTEs: boolean): void {
        if (this.dependencyAnalyzer.hasCircularDependency() && !hasRecursiveCTEs) {
            throw new Error(CTEQueryDecomposer.ERROR_MESSAGES.CIRCULAR_REFERENCE);
        }
    }

    /**
     * Processes CTE nodes and generates decomposed CTEs
     * @param query Original query
     * @param nodes CTE dependency nodes
     * @param recursiveCTEs List of recursive CTE names
     * @returns Array of decomposed CTEs
     */
    private processCTENodes(
        query: SimpleSelectQuery, 
        nodes: CTENode[], 
        recursiveCTEs: string[]
    ): DecomposedCTE[] {
        const result: DecomposedCTE[] = [];

        for (const node of nodes) {
            const isRecursive = recursiveCTEs.includes(node.name);
            
            if (isRecursive) {
                result.push(this.createRecursiveCTE(node, query));
            } else {
                result.push(this.createStandardCTE(node, nodes));
            }
        }

        return result;
    }

    /**
     * Creates a decomposed CTE for recursive CTEs
     */
    private createRecursiveCTE(node: CTENode, query: SimpleSelectQuery): DecomposedCTE {
        const formattedQuery = this.formatter.format(query).formattedSql;
        const finalQuery = this.addCommentsToQuery(formattedQuery, node.name, [], [], true);
        
        return {
            name: node.name,
            query: finalQuery,
            dependencies: [],
            dependents: [],
            isRecursive: true
        };
    }

    /**
     * Creates a decomposed CTE for standard (non-recursive) CTEs
     */
    private createStandardCTE(node: CTENode, allNodes: CTENode[]): DecomposedCTE {
        const query = this.buildExecutableQuery(node, allNodes);
        const finalQuery = this.addCommentsToQuery(query, node.name, node.dependencies, node.dependents, false);
        
        return {
            name: node.name,
            query: finalQuery,
            dependencies: [...node.dependencies],
            dependents: [...node.dependents],
            isRecursive: false
        };
    }

    /**
     * Builds an executable query for a CTE by including its dependencies
     */
    private buildExecutableQuery(targetNode: CTENode, allNodes: CTENode[]): string {
        const requiredCTEs = this.collectRequiredCTEs(targetNode, allNodes);
        
        if (requiredCTEs.length === 0) {
            // No dependencies, just return the CTE's query
            return this.formatter.format(targetNode.cte.query).formattedSql;
        }

        // Build WITH clause with required CTEs
        const withClause = this.buildWithClause(requiredCTEs);
        const mainQuery = this.formatter.format(targetNode.cte.query).formattedSql;
        
        return `${withClause} ${mainQuery}`;
    }

    /**
     * Collects all required CTEs for a target CTE in dependency order
     */
    private collectRequiredCTEs(targetNode: CTENode, allNodes: CTENode[]): CTENode[] {
        const visited = new Set<string>();
        const result: CTENode[] = [];
        const nodeMap = new Map<string, CTENode>();
        
        // Build node lookup map
        for (const node of allNodes) {
            nodeMap.set(node.name, node);
        }

        const collectDependencies = (nodeName: string) => {
            if (visited.has(nodeName)) return;
            visited.add(nodeName);

            const node = nodeMap.get(nodeName);
            if (!node) return;

            // First collect all dependencies
            for (const depName of node.dependencies) {
                collectDependencies(depName);
            }

            // Then add this node (ensuring dependencies come first)
            if (nodeName !== targetNode.name) {
                result.push(node);
            }
        };

        // Collect dependencies for the target node
        for (const depName of targetNode.dependencies) {
            collectDependencies(depName);
        }

        return result;
    }

    /**
     * Builds WITH clause from required CTEs
     */
    private buildWithClause(requiredCTEs: CTENode[]): string {
        if (requiredCTEs.length === 0) return "";

        const cteDefinitions = requiredCTEs.map(node => {
            const cteName = node.name;
            const cteQuery = this.formatter.format(node.cte.query).formattedSql;
            return `${cteName} as (${cteQuery})`;
        });

        return `with ${cteDefinitions.join(", ")}`;
    }

    /**
     * Finds recursive CTEs in the query
     * @param query The query to analyze
     * @param ctes All CTEs in the query
     * @returns Array of recursive CTE names
     */
    private findRecursiveCTEs(query: SimpleSelectQuery, ctes: CommonTable[]): string[] {
        if (!query.withClause || !this.isRecursiveWithClause(query)) {
            return [];
        }

        // For now, assume all CTEs in a RECURSIVE WITH are recursive
        // This is a simplification - in reality, only some CTEs might be recursive
        return ctes.map(cte => this.getCTEName(cte));
    }

    /**
     * Checks if a WITH clause is recursive
     * @param query The query to check
     * @returns true if the query contains WITH RECURSIVE
     */
    private isRecursiveWithClause(query: SimpleSelectQuery): boolean {
        const queryText = this.formatter.format(query).formattedSql.toLowerCase();
        return queryText.includes('with recursive');
    }

    /**
     * Adds comments to the query if addComments option is enabled
     * @param query The query string to add comments to
     * @param cteName The name of the CTE
     * @param dependencies Array of dependency names
     * @param dependents Array of dependent names
     * @param isRecursive Whether this is a recursive CTE
     * @returns Query with comments added if enabled, otherwise original query
     */
    private addCommentsToQuery(
        query: string, 
        cteName: string, 
        dependencies: string[], 
        dependents: string[], 
        isRecursive: boolean
    ): string {
        if (this.options.addComments !== true) {
            return query;
        }

        try {
            // Parse the query to add comments to its AST
            const parsedQuery = SelectQueryParser.parse(query) as SimpleSelectQuery;
            
            // Generate comment lines
            const comments = this.generateComments(cteName, dependencies, dependents, isRecursive);
            
            // Add comments to the root query (this should place them at the beginning)
            comments.forEach(comment => {
                CommentEditor.addComment(parsedQuery, comment);
            });
            
            // Format with comment export enabled
            const formatterWithComments = new SqlFormatter({
                ...this.options,
                exportComment: true
            });
            
            return formatterWithComments.format(parsedQuery).formattedSql;
        } catch (error) {
            // If parsing fails, return original query with simple text comments
            console.warn(`${CTEQueryDecomposer.ERROR_MESSAGES.PARSING_FAILED}: ${error}`);
            return this.addTextCommentsToQuery(query, cteName, dependencies, dependents, isRecursive);
        }
    }

    /**
     * Generates comment lines for a CTE
     * @param cteName The name of the CTE
     * @param dependencies Array of dependency names
     * @param dependents Array of dependent names
     * @param isRecursive Whether this is a recursive CTE
     * @returns Array of comment strings
     */
    private generateComments(
        cteName: string, 
        dependencies: string[], 
        dependents: string[], 
        isRecursive: boolean
    ): string[] {
        const { AUTO_GENERATED, ORIGINAL_CTE, DEPENDENCIES, DEPENDENTS, RECURSIVE_TYPE, NONE } = CTEQueryDecomposer.COMMENT_TEXTS;
        const comments: string[] = [];
        
        comments.push(AUTO_GENERATED);
        comments.push(`${ORIGINAL_CTE} ${cteName}`);
        
        if (isRecursive) {
            comments.push(RECURSIVE_TYPE);
        }
        
        const depsText = dependencies.length > 0 ? dependencies.join(", ") : NONE;
        comments.push(`${DEPENDENCIES} ${depsText}`);
        
        const dependentsText = dependents.length > 0 ? dependents.join(", ") : NONE;
        comments.push(`${DEPENDENTS} ${dependentsText}`);
        
        return comments;
    }

    /**
     * Adds text comments as SQL comments when AST parsing fails
     * @param query Original query
     * @param cteName The name of the CTE
     * @param dependencies Array of dependency names
     * @param dependents Array of dependent names
     * @param isRecursive Whether this is a recursive CTE
     * @returns Query with text comments prepended
     */
    private addTextCommentsToQuery(
        query: string, 
        cteName: string, 
        dependencies: string[], 
        dependents: string[], 
        isRecursive: boolean
    ): string {
        const comments = this.generateComments(cteName, dependencies, dependents, isRecursive);
        const commentLines = comments.map(comment => `-- ${comment}`).join('\n');
        return `${commentLines}\n${query}`;
    }

    /**
     * Extracts the name from a CommonTable
     */
    private getCTEName(cte: CommonTable): string {
        return cte.aliasExpression.table.name;
    }
}